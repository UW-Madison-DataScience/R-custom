---
title: "R for text data"
author: "Tobin Magle, Sarah Stevens"
teaching: 
exercises: 
questions:
- 
objectives:
- 
keypoints:
- 
source: Rmd
---

```{r, echo = FALSE, purl = FALSE, message = FALSE}
source("../bin/chunk-options.R")
```

## Outline

<!--- Faceting -> factors in forcats, or dplyr::distinct -->
<!--- Clustering - there are ways to do this in R, but i’ve taught it before andit’s pretty confusing. Maybe show them how to recode with forcats instead? -->
- Reminder about what factors are
- Recoding factors 
- Reorder factors
- Joining two string vectors
- Remove leading/trailing whitespace
- Split - tidyr::separate <!--- Maybe? -->
<!--- Filtering - do we need to repeat this from dplyr? S: no? -->
- Sorting - dplyr::arrange <!--- Maybe? -->
<!--- Numbers + numeric facets - not sure this makes sense either, S: yeah I'm not sure what you mean here -->
- Saving - maybe reiterate write_csv

<!--- Link to slides from my first try at teaching this stuff as "data cleaning": (https://docs.google.com/presentation/d/1iZYep0u5OPQjkchEzLxYencLcQhoKYsK_3FvfzojK5c/edit#slide=id.g2a7f47f09d_1_121) -->


## Setup

```{r setup}
library(stringr)
library(forcats)
library(readr)
library(ggplot2)
library(dplyr)

surveys <- read.csv("data/raw_surveys.csv")
```


## Factors

Factors are...<!--- fill in -->


<!--- Challenge - which columns should be set as factors? -->


## Recoding factors

One common function we may need to perform is recoding the factors.
In this case we may want to use the month names, instead of their numbers.

```{r}
surveys$month_abbv <- surveys$month %>% as.factor() %>% 
  fct_recode(Jan='1', Feb='2', Mar='3', Apr='4', May='5', 
             Jun='6', Jul='7', Aug='8', Sep='9', Oct='10',
             Nov='11', Dec='12')
head(surveys)
```

### Easier way to do this.

Getting the month abbreviations recoded more easily.
First let's look at the first 6 months.
````{r}
surveys$month %>% head()
```

Now we can use the `month.abb[]` to get back the abbreviated names.
(Still looking at only the first 6)
```{r}
month.abb[surveys$month] %>% head()
```

You can also do this with the full month name using `month.name[]`
```{r}
month.name[surveys$month] %>% head()
```

> ## Challenge
>
>  Add a new column called `month_full` onto the `surveys` data 
>  from that includes the full month name.
> 
> Hint: Check out what `month.name[]` does.
>
> > ## Solution to Challenge
> > ```{r, answer=TRUE, eval=FALSE, purl=FALSE}
> > surveys$month_full <- month.name[surveys$month]
> > ```
> {: .solution}
{: .challenge}


## Reorder factors

If we use the ggplot skills we learned in the last session.
We see that the factors for `plot_type` display in the order of their 
levels, which are in alphabetical order by default.
```{r}
levels(surveys$plot_type)
surveys %>% filter(!is.na(hindfoot_length)) %>% 
  ggplot(aes(x=plot_type, y=hindfoot_length)) +
  geom_boxplot()
```


### Control on the right

Suppose we need the control to be on the right side of our plot instead.
Before we would have to use the following code.
```
surveys$plot_type <- factor(surveys$plot_type, levels = c("Long-term Krat Exclosure", "Rodent Exclosure", "Short-term Krat Exclosure", "Spectab exclosure", "Control"))
```

Instead with the tidyverse we can use the function `fct_relevel` and specify the placement of "Control" with
`after=Inf` (after everything) instead of typing out each of the levels.

```{r}
surveys$plot_type <- surveys$plot_type %>% fct_relevel("Control", after= Inf)
```

Now if we plot the same boxplot above, the Control is the to the far right.
You can this to reorder the categories in your other plots as well.

```{r}
surveys %>% 
  filter(!is.na(hindfoot_length)) %>% 
  ggplot(aes(x=plot_type, y=hindfoot_length)) +
  geom_boxplot()
```

> ## Challenge
>
>  1. Make a box plot of the hindfoot lenghts by `plot_id`. 
>  Hint: you may need to change the data type.
>  2. Figure out which `plot_id`'s belong to the "Control" `plot_type.  
>  Hint: You may want to the `dplyr` skills we've learned and the `unique()` function.
>  3. Reorder the `plot_id`'s in the boxplot so the control plots are on the right.
>
> > ## Solution to Challenge
> > 1. 
> > ```{r, answer=TRUE, eval=FALSE, purl=FALSE}
> > surveys$plot_id <- as.factor(surveys$plot_id)
> > surveys %>% 
> >     filter(!is.na(hindfoot_length)) %>% 
> >     ggplot(aes(x=plot_id, y=hindfoot_length)) +
> >     geom_boxplot()
> > ```
> > 2. 
> > ```{r, answer=TRUE, eval=FALSE, purl=FALSE}
> > ctrl_id <- surveys %>% filter(plot_type == "Control") %>% select(plot_id) %>%  unique()
> > ```
> > 3. 
> > ```{r, answer=TRUE, eval=FALSE, purl=FALSE}
> > surveys$plot_id <- surveys$plot_id %>% fct_relevel('2', '17', '12', '11', '22', '14', '4', '8', after= Inf)
> > surveys %>% 
> >     filter(!is.na(hindfoot_length)) %>% 
> >     ggplot(aes(x=plot_id, y=hindfoot_length)) +
> >     geom_boxplot()
> > ```
> {: .solution}
{: .challenge}

<!--- alt challenge, reorder months in plot? 
surveys %>% filter(!is.na(weight)) %>% ggplot(aes(x=month_abbv, y=weight)) + geom_boxplot()
-->

## Make a Scientific Name column

In some of our plots we may want to label with the full scientific name.
To do so we can add a new column which joins two strings together.
Before we get into vectors lets try an example with two strings
```{r}
name = "Sarah"
str_c("Hi my name is ", name)
```

We can similarlly use this on vectors.

```{r}
surveys$sci_name <- str_c(surveys$genus, " ",  surveys$species)
```

Now we could make a plot and have it labeled by the full scientific name.
Another function that you could have used here is `paste()`

## Remove leading/trailing whitespace

For this example, let's read in a messy version of the data.
Convienently, there are some whitespace issues in the first few entries of `scientificName`.
Let's take a look.

```{r}
messy_surveys <- read.csv("data/Portal_rodents_19772002_scinameUUIDs.csv")
head(messy_surveys)
messy_surveys$scientificName %>% head()
```

The spacing here shows us that there is probably something.  It is a little easier
to see if we view it as a character vector instead of a factor in this case.

```{r}
messy_surveys$scientificName %>% as.character() %>% head()
```

Now we can see that there are both leading and trailing spaces in these first view entries.
We can use `str_trim()` to trim off white space.  It takes two arguments, the character vector
and `side` which indicates which side we want to trim.  We will use "both" since we have both
leading and trailing whitespace.

```{r}
messy_surveys$scientificName %>% str_trim(side="both") %>% head()
```

Let's replace this column in our messy dataset to clean it up a little.
Note we don't want to use `head()` this time.

```{r}
messy_surveys$scientificName <- messy_surveys$scientificName %>% str_trim(side="both")
```


## Regular expressions


## Left pad the months, for data consistency

In the past we've seen cases where sorting on number characters/factors 
can behave differently than expected.
If we want to avoid this we can add zero's on the left side and make our numbers
a consistent length.

```{r}
samp_ids <- c("1", "10", "100", "200")
```

First we should look up the arguments for `str_pad` the function we need to use.

From the help we can see that we need the character vector, and the following 
addtional arguments: `width`, `side`, and `pad`.

```{r}
str_pad(samp_ids, width = 3, side = "left", pad="0")
```

Now we can try this on our dataset.

```{r}
surveys$month <- surveys$month %>% 
  str_pad(width = 2, side = "left", pad='0')
head(surveys)
```

> ## Challenge
>
>  Try the same thing with the `day` column.
> 
>
> > ## Solution to Challenge
> > ```{r, answer=TRUE, eval=FALSE, purl=FALSE}
> >  surveys$day <- surveys$day %>% 
> >   str_pad(width = 2, side = "left", pad='0')
> > ```
> {: .solution}
{: .challenge}



## Write back to a csv file





