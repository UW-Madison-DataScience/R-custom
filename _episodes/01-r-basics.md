---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 01-r-basics.md in _episodes_rmd/
title: "R basics"
author: "Tobin Magle"
teaching: 
exercises: 
questions:
- 
objectives:
- 
keypoints:
- 
source: Rmd
---


Based on (http://www.datacarpentry.org/R-ecology-lesson/)

# Intro to R and RStudio

Many researchers use programming languages to automate the processing, analysis and visualization of their research data. **R** is a popular programming language that was initially designed as an open source statistical language. **RStudio** is a popular integrated development environment that makes working with R code easier. 

## Installation
R and RStudio must be installed separately for this lesson. The Data Carpentry Ecology lesson has excellent [setup instructions](https://datacarpentry.org/R-ecology-lesson/#setup_instructions)

## Why learn R?

Now that we have the software installed, let’s discuss why we might want to learn to code in R:

* First, R is free, open source and cross platform, allowing you to take it to any organization you may work at in the future. 
* R is also widely used for research computing. In fact, the R has over 10,000 extensions called packages, many of which were created by researchers.
* These packages allow R to import a variety of data types, from tabular and geospatial data, to text and genomic sequences.
* R also produces high quality, publication ready graphs. The code can be reused to make other graphs for similar data.
* Finally, coding in any language will make the analysis that you do more reproducible. With R, you can share executable scripts with colleagues, providing an exact accounting of what you did.

## Setting up your working directory

Good file organization practices are key to writing good code. 

> ## Hands on: Set up your project directory
> Follow these steps to set up your project directory
>
> * Open RStudio 
> * File >  New project > New directory > Empty project
> * Enter a name for this new folder: r-basics
> * Choose a convenient location: ~/Desktop
> * Click “Create project” 
>
> > ## Outcome
> > Your RStudio window should look like this:
> > <insert the image with annotation>
> > 
> {: .solution}
{: .challenge}

> ## Hands on: Create an R Script
> Follow these steps to set up your project directory
>
> * File > New File > R script
> * Save it in your project directory
> 
> > ## Outcome
> > Your RStudio window should look like this:
> > <insert the image with annotation>
> > 
> {: .solution}
{: .challenge}

The RStudio interface is made up of 4 windows: 

* The **script** window (upper right) is where you edit the text document that holds your code. The name of the file on the tab turns red when the file is not saved.
* The **console** (lower left) is where the code gets executed and output, such as warnings and error messages, are displayed.
* The **environment** tab (upper right) is shows the objects (ex: data) stored in the computer’s memory. You can also see what has been run in the console using the history tab.
* The **files** tab (lower right) shows your *working directory* and the files are contained in that directory.

## Scripts vs. the console

You have probably noticed that we have two places that accept code as input: the script and console windows

* Both of these windows will accept R commands
* The Console runs the commands, but doesn’t save them permanently, though they appear in the history tab on the upper right
* The script is where you save commands to run later. Once you type code in the script, you still need to send them to the console to be run.
* You can send the code to the console by copying and pasting, or putting your cursor on the line that you want to run, and pressing control enter on PC and command enter on the mac, or by hitting the run button at the top of the script window

# Operators and functions

Now that we're familiar with the RStudio interface, let's get coding! R scripts are written as a combination of **operators** and **functions**. Operators are symbols that perform operations on the values to the left and right of the symbol. Functions are similar, but are represented by a name that takes varying numbers of inputs. Both produce output. Let's take a look at operators first. 

## Types of operators

There are four basic operator types that are common in R and other programming languages. This table lists the categories, what they do, and what symbols are included in the category. 

Type|What it does|Symbol(s)
---|---|---
Arithmetic|Math on numbers|+ - * / ^
Assignment|Creates or changes contents of objects |<-
Extraction|Take out or replace part of an object|[ ] $ 
Logical|Compares values, returns TRUE/FALSE|>   <   ==   !   %in%  &   |

### Arithmetic operators

Arithmetic operators allow R to do math like add, subtract, multiply, and divide on numbers or variables. 

* These operators are useful with data because they allow us to compute unit conversion
* By default, the result of the mathematical computations goes to the console.


~~~
#Add: 
2+2
~~~
{: .language-r}



~~~
[1] 4
~~~
{: .output}



~~~
#Subtract: 
3-1
~~~
{: .language-r}



~~~
[1] 2
~~~
{: .output}



~~~
#Multiply: 
4*4
~~~
{: .language-r}



~~~
[1] 16
~~~
{: .output}



~~~
#Divide: 
5/2
~~~
{: .language-r}



~~~
[1] 2.5
~~~
{: .output}

But what if we want to save the results to use later? 

### The assignment operator

The assignment operator (`<-`)saves values into objects (named containers that store values) to the R environment (the upper right pane). 

For example, we can assign the value 55 to the variable weight_kg.


~~~
 weight_kg <- 55
~~~
{: .language-r}

The values in these variables can be overwritten by a second assignment operation, 

~~~
weight_kg <- 66
~~~
{: .language-r}

The assignment operator can also can be combined with arithmetic operators.

~~~
weight_lb <- 2.2*weight_kg
~~~
{: .language-r}

> ## Challenge: Operators
> What are the values of each variable after each statement?
> 
> ```r
> mass <- 47.5                          # mass?
> age  <- 122                           # age?
> mass <- mass * 2.0                    # mass?
> age  <- age - 20                      # age?
> mass_index <- mass/age                # mass_index?
> ```
>
> > ## Solution
> > 
> > ```r
> > mass <- 47.5                      # mass is 47.5
> > age  <- 122                       # age is 122
> > mass <- mass * 2.0                # mass is 95
> > age  <- age - 20                  # age age is 102
> > mass_index <- mass/age            # mass_index is 0.9313725
> > ```
> >
> {: .solution}
{: .challenge}

## Functions

For more complicated tasks, R also comes pre-installed with a variety of **functions**. 
* Functions are a sequence of steps that perform a specific task.
* Each function has a name
* They accept input in the form of arguments,
and returns a value that can be assigned to a variable as output.

Let's look at some example functions: `sqrt()` and `round()`.

The square root function `sqrt()` takes a number as input (called an **argument**) and returns the square root of that number as output. 


~~~
sqrt(9)
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}

Functions usually take at least one argument as input, but can take multiple. Let's look at the `round()` function as an example. 

The `round()` function takes at minimum a number as input and returns a rounded number as output.


~~~
round(3.14159)
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}

By default, the number is rounded to the nearest whole number. We can change this behavior by using additional arguments. But how do we know what they are? The quickest way to get to the documentation about a function that you know the exact name is to use the `?` operator, which opens the function's help file in the **Help** tab in the lower right pane.


~~~
?round
~~~
{: .language-r}

This help file has information for a group of functions that are related to `round()` (`ceiling()`, `floor()`, etc.). In the usage section, we can see an example of how to use the round function:

> round(x, digits = 0)

This line tells the user that round can take up to 2 arguments: `x` and `digits`. The **Arguments** section defines what these arguments are. 

Argument name| Definition
----|-----
x	|a numeric vector. Or, for round and signif, a complex vector
digits	|integer indicating the number of decimal places (round)

We've been using the `x` argument implicitly: this is the number to be rounded. The `digits` argument has its default value set to 0, meaning that it will round to 0 decimal places. If we change this argument to 2, it will round to 2 decimal places. 


~~~
round(x = 3.14159, digits = 2)
~~~
{: .language-r}



~~~
[1] 3.14
~~~
{: .output}

You don't always need to name the arguments explicitly.


~~~
round(3.14159, 2)
~~~
{: .language-r}



~~~
[1] 3.14
~~~
{: .output}

However, this can get confusing with functions that have many arguments. For example, if you put the arguments in the wrong order, you can get some unexpected results.  


~~~
round(2, 3.14159)
~~~
{: .language-r}



~~~
[1] 2
~~~
{: .output}

In the previous example, `round()` is trying to round the number 2 to 3.14159 decimal places. You can put them in this order if you use their names though. 


~~~
round(digits=2, x = 3.14159)
~~~
{: .language-r}



~~~
[1] 3.14
~~~
{: .output}

# Data Types
Now that we know how to use operators and functions to perform operations on values and objects using R, let's talk a bit about the data itself. When you save a value into an object using the assignment operator, R evaluates the value and assigns a **data type** to the object. 

* Data type is important, because it determines what operators and functions you can use with the object
* The basic data types in R are `numeric`, `character` and `logical`. We'll show examples of these types in this lesson
* This type represents R's best guess at what type the data represents. It's usually pretty easy to tell what data type an object is if it has a single element.
* You can use the `class()` function to check what type R thinks the data is

R interprets numbers (both integers and decimal numbers) as `numeric` data. 


~~~
x <- 32
class(x)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}

Numeric data works with the arithmetic operators and the `tound()` and `sqrt()` functions that we've already discussed. 


~~~
x+x
~~~
{: .language-r}



~~~
[1] 64
~~~
{: .output}



~~~
sqrt(x)
~~~
{: .language-r}



~~~
[1] 5.656854
~~~
{: .output}

R interprets anything enclosed in quote marks (`''` or `""`) as the `character` data type. I


~~~
y <- "hi"
class(y)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

If you try to use a character object with arithmetic operators or functions that take numeric input, you will get an error message. 


~~~
y+y
~~~
{: .language-r}



~~~
Error in y + y: non-numeric argument to binary operator
~~~
{: .error}



~~~
sqrt(y)
~~~
{: .language-r}



~~~
Error in sqrt(y): non-numeric argument to mathematical function
~~~
{: .error}

Character objects are used with other functions like `paste()`, which joins strings together, separated by a space by default.


~~~
paste(y,y)
~~~
{: .language-r}



~~~
[1] "hi hi"
~~~
{: .output}

Use the `sep` argument to change the separator

~~~
paste(y,y, sep = '.')
~~~
{: .language-r}



~~~
[1] "hi.hi"
~~~
{: .output}

R interprets the special values `TRUE` and `FALSE` (not in quotes) as logical data. 


~~~
z <- TRUE
class(z)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}

The usage of logical data is a bit complicated and makes more sense with more complex data structures, so we'll discuss this in more depth later. 

# Data structures

So far, we’ve been dealing with rather simple data: one value stored in an object. But R has more complex data structures that make working with large datasets easier. The ones we’re going to be talking about today are Vectors and Data Frames.

Let’s take a closer look at `vectors` first.

## Vectors

R can stores multiple values of the same type in a data type called a `vector`.

* Like other objects, `vectors` are assigned values using the assignment operator
* We use the c() or concatenate function to create vectors
* Each value is separated by a comma
* R assigns vectors a type based on the content

Example: a list of weights


~~~
weight_g<-c(50, 60, 65, 82)
class(weight_g)
~~~
{: .language-r}



~~~
[1] "numeric"
~~~
{: .output}

Example: a list of species


~~~
animals<-c('mouse', 'rat', 'dog')
class(animals)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

Vectors have a couple of notable characteristics: their length and what type of values are present.

The `length()` function returns an integer representing the number of values in the vector object.


~~~
length(weight_g)
~~~
{: .language-r}



~~~
[1] 4
~~~
{: .output}



~~~
length(animals)
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}

The `str()` or structure function tells you have the class, length and also lists the values found in the vector.


~~~
str(weight_g)       
~~~
{: .language-r}



~~~
 num [1:4] 50 60 65 82
~~~
{: .output}



~~~
str(animals)
~~~
{: .language-r}



~~~
 chr [1:3] "mouse" "rat" "dog"
~~~
{: .output}

You can also add values to a vector using the `c()` function by using an existing vector as an argument. The elements will be added in the order that they appear as arguments to the `c()` function.


~~~
#Add to the end of the vector:
weight_g <- c(weight_g, 90)

#Add to the beginning of the vector:
weight_g <- c(30, weight_g)
~~~
{: .language-r}

## Class coercion

We’ve said that vectors can only hold one data type. 
So what happens if you try to make a vector with multiple data types? R uses **class coercion** to force all of the values to fit into the same type. 

* R looks at the data elements as a whole and finds a data type that can accommodate all of the elements
* R has ways to accommodate anything include making everything into a character or reading logical values `FALSE` and `TRUE` as 0 and 1 respectively.

By default, it opts for the most permissive type, but you can force R to interpret values as a certain type by using functions like `as.numeric()`, `as.character()` and `as.logical()`. Here are general rules that R follows while converting between types:

* R can put quotes around any value to represent it as string
* R can interpret `TRUE` as the number 1 and `FALSE` as the number 0
* Unless there is a number/`TRUE`/`FALSE` stored inside a string, R won't be able to interpret it as anything but a character
* `NA`, which is a special object in R that represents missing data, means that R could not meaningfully convert between these types.

Examples: 

Value|Type|As  character|As numeric|As logical
---|---|---|---
`TRUE`|logical|"TRUE"|1|TRUE
35|numeric|"35"|35|`NA`
"badger"|character|“badger”|`NA`|`NA`
"24"|character|"24"|24|`NA`
"FALSE"|character|`NA`|`FALSE`

> ## Challenge: class coercion
> The question goes here
>
> What types are these vectors?
>
> ```r
> num_char <- c(1, 2, 3, "a")
> num_logical <- c(1, 2, 3, TRUE)
> char_logical <- c("a", "b", "c", TRUE)
> tricky <- c(1, 2, 3, "4")
> ```
>
> Hint: use class()
> 
> > 
> > class(num_char) is `character`
> > class(num_logical) is `numeric`
> > class(char_logical) is `character`
> > class(tricky) is `character`
> > 
> {: .solution}
{: .challenge}

## Subsetting vectors
When working with data, it's often useful to pull out a subset of a data set. Luckily, R has the subset operator ([] aka "square brackets"). This operator allows users to subset elements by their position or by their value.

### Subsetting by position

To select a vector element by its position:

* name the vector you want to subset
* follow the name by the subset operator `[]`
* put the position number of the element you want inside the square brackets. Note: in R, the position of the first element is 1.

Here's an example of how to subset the second element of the following vector. 


~~~
animals<-c('mouse', 'rat', 'dog')

#Display second value
animals[2]
~~~
{: .language-r}



~~~
[1] "rat"
~~~
{: .output}

The subset also allows you to select multiple elements at once using using the `c()` function. As we saw before, the `c()` function creates a vector object with the elements provided as input, in the order that they are provided. This vector is used by the subset operator to pull elements out by their position.


~~~
animals[c(3,2)] 
~~~
{: .language-r}



~~~
[1] "dog" "rat"
~~~
{: .output}



~~~
#Display repeated values
animals[c(1,2,3,2,1)]
~~~
{: .language-r}



~~~
[1] "mouse" "rat"   "dog"   "rat"   "mouse"
~~~
{: .output}

If you want to select a sequential set of elements, you can use the **slice operator** (`:`). The slice operator creates a vector that starts with the integer before the operator and ends with the integer after the operator. For example, the slice `1:6` would create a vector with the values `1 2 3 4 5 6`. This vector can be used as input to the subset operator.


~~~
animals[1:2] 
~~~
{: .language-r}



~~~
[1] "mouse" "rat"  
~~~
{: .output}

### Subsetting vectors by element values

With large datasets, the value of the elements are often more important than their position. The subset operator can takes a logical vector the same length as the subsetted vector as input. The operator goes through the length of these vectors and keeps the elements at the same positions as `TRUE` values in the logical vector and drops the ones at the same position as `FALSE` values.

For example, the following code will keep 1 and 3 and drop 2.


~~~
logical<-c(TRUE, FALSE, TRUE)
to_subset<-c(1, 2, 3)

to_subset[logical]
~~~
{: .language-r}



~~~
[1] 1 3
~~~
{: .output}

#### Using comparison operators
Generating these logical vectors is often done using **comparison operators**. **Comparison operators** compare the value to the left of the operator to the value to the right of the operator and return either `TRUE` or `FALSE`. 

##### Table of comparison operators
Comparison Operator|Meaning|what it does
---|---|---
`>`|Greater than|`TRUE` if the value on the left is bigger than the value on the right
`<`|Less than|`TRUE` if the value on the left is smaller than the value on the right
`==`|Equal to|`TRUE` if the values are the same
`!=`|Not equal to| `TRUE` if the values are different
`%in%`|Contained in|`TRUE` if the value on the left is equal to any element of the vector on the right

For example, if we wanted all of the animals with a weight greater than 50 grams, you'd use the following expressions


~~~
weight_g <- c(21, 34, 39, 54, 55) 

weight_g>50
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE  TRUE  TRUE
~~~
{: .output}
The last 2 values would be kept, because they're greater than 50. Let's save the logical vector and use it to subset


~~~
weight_tf<-weight_g>50

weight_g[weight_tf]
~~~
{: .language-r}



~~~
[1] 54 55
~~~
{: .output}
You can also skip making the weight_tf object if you put the expression directly inside the subset operator.


~~~
weight_g[weight_g>50]
~~~
{: .language-r}



~~~
[1] 54 55
~~~
{: .output}

The less than (`<`), equal to (`==`) and not equal to (`!=`) operators work similarly with numeric values. 

#### Using logical operators
**Logical operators** allow you to create complex expressions by combining comparison statements. These  operators can be combined to specify complex conditions.

##### Table of logical operators

Logical Operator|Meaning|what it does
---|---|---
`&`|and|`TRUE` if both values are `TRUE`
`|`|or|`TRUE`either are `TRUE`
`!`|not|flip `TRUE` to `FALSE` and `FALSE` to `TRUE`

For example, you can use the OR operator to select outliers, like weights under 30 or weights over 50


~~~
#Weights under 30 or over 50:
weight_g[weight_g < 30 | weight_g > 50]
~~~
{: .language-r}



~~~
[1] 21 54 55
~~~
{: .output}

Or you can use the AND operator to get weights between 30 and 50 


~~~
#Weights over 30 and under 50:
weight_g[weight_g > 30 & weight_g < 50]
~~~
{: .language-r}



~~~
[1] 34 39
~~~
{: .output}

#### Comparing character objects

Comparison operators also work with character objects. 
* `==` will return TRUE if the characters are the same
* `!=` will return TRUE if the characters are not the same
* The greater than (`>`) and less than (`<`) operators don't make as much sense with character objects, but will return a result based on the alphabetical order of the characters.  

For example, let's try extracting all "cat" values from the vector animals using `==`.


~~~
animals <- c("cat","mouse", "rat", "dog", "cat")

#Animals that are cats: 
animals[animals == "cat"]
~~~
{: .language-r}



~~~
[1] "cat" "cat"
~~~
{: .output}

We can also exclude elements with the value 'cat' using `!=`.


~~~
#Animals that are not cats: 
animals[animals != "cat"]
~~~
{: .language-r}



~~~
[1] "mouse" "rat"   "dog"  
~~~
{: .output}

You can also use logical operators to include multiple character values.


~~~
#Animals that are cats or rats: 
animals[(animals == "cat") | (animals == "rat")]
~~~
{: .language-r}



~~~
[1] "cat" "rat" "cat"
~~~
{: .output}

This syntax works for a small number comparisons, but it can get very redundant when you have a long list to compare values to. For that situation, the `%in%` operator is more concise. 
* this operator compares two vectors
* for each element of the first vector (on the left), this operator returns `TRUE` when this element is found in the second vector and `FALSE` when it is not.

The previous example can be written with the `%in%` operator instead of the `|` operator.


~~~
catrat<-c("cat", "rat")
#Animals that are cats: 
animals[animals %in% catrat]
~~~
{: .language-r}



~~~
[1] "cat" "rat" "cat"
~~~
{: .output}

> ## Challenge: Conditional subsetting
>
> The following equal length vectors represent data from 8 observations from an experiment involving trapping animals in the wild and recording their species using a 2 digit id and their weight in grams.
>
> ```r
> record_id <- c(1, 2, 3, 4, 5, 6, 7, 8)
> weights <- c(51,63, 28, 32, 68, 55, 36, 41)
> species_id <- c("AB","AB","AM","AM","AB","AB","AM","AM")
> ```
> 1. Write a comparison statement that includes weights>30
> 2. Write a comparison statement that includes species ids "AB"
> 3. Write a logical statement that returns the record IDs of animals that have weights greater than 30 and have the species id "AB".
> 
> > ## Solution
> > 1. Subset the weights vector
> > ```r
> > weights[weights>30]
> > ```
> > 
> > 2. Subset the species_id vector
> > ```r
> > species_id[species_id == "AM"]
> > ```
> > 
> > 3. Subset the record_id vector
> > ```r
> > record_id[weights>30 & species_id == "AM"]
> > ```
> >
> {: .solution}
{: .challenge}

# Missing values

When collecting data in the real world, it's not always feasible to have a complete dataset. For example, if you're trapping animals in the wild, sometimes they get away from you before you can get an accurate weight measurement. It might seem intuitive to leave the data blank in this case, but blank data can lead to uncertainty. What if you forgot to enter a value? What if you hadn't filled that value in yet? What if you accidentally hit the delete button in that cell?

This is why programming languages often have a marker for missing data. `NA` is the special value in R that represents missing data. This marker lets the user know when missing data exists, but also provides ways to ignore the missing values in appropriate situations

For example, if you try to do math on a numeric vector that has a missing value designated by `NA`, the function will return `NA` as the results to let you know that there is missing data.


~~~
heights <- c(2, 4, 4, NA, 6)

# Mean of a vector with a missing value?
mean(heights)
~~~
{: .language-r}



~~~
[1] NA
~~~
{: .output}

This behavior is good because if you weren't expecting missing data, you want to know that it's there before doing more calculations. If you were expecting missing data and want to ignore if for the purposes of a calculation, many mathematical functions have the argument `na.rm`, which stands for remove missing data. By default, `na.rm = FALSE` which tells R not to ignore the missing data. Setting `na.rm = TRUE` will calculate the mean while ignoring the missing data. 


~~~
# Remove the missing data
mean(heights, na.rm = TRUE)
~~~
{: .language-r}



~~~
[1] 4
~~~
{: .output}

However, not all functions have the `na.rm` argument. Luckily, R has other functions that identify and remove missing data.

The `na.omit()` function takes an object as input returns the with the missing values removed.


~~~
na.omit(heights)
~~~
{: .language-r}



~~~
[1] 2 4 4 6
attr(,"na.action")
[1] 4
attr(,"class")
[1] "omit"
~~~
{: .output}
Two other functions rely on logical vectors and the subset operator to remove missing values.

* The `is.na()` function takes an object as input and  returns TRUE if the value its evaluating is NA. To remove `NA`s using `is.na()` you also need to use the not operator (`!`), which changes TRUE to false and vice versa.

* The `complete.cases()` function takes an object as input and returns FALSE if the value is missing, so it can be used directly in the subset operator


> ## Challenge: missing values
> The question goes here
>
> Use more carats for new lines 
>
> 
> > ## Solution Goes here
> > text like this
> > ```r
> > # r code goes here
> > ```
> {: .solution}
{: .challenge}

# Loading data tables 

> ## Challenge Format
> The question goes here
>
> Use more carats for new lines 
>
> 
> > ## Solution Goes here
> > text like this
> > ```r
> > # r code goes here
> > ```
> {: .solution}
{: .challenge}



<!--- HTML comment 
Comments
-->

# Glossary
* R
* RStudio
* open source
* cross platform
* packages
* reproducibility
* script
* console
* environment
* working directory
* operators
* arithmetic operator
* assignment operator
* functions 
* arguments
* data type
* vector
* element
* coersion
* subsetting
* subset operator
* slice operator
* comparison operators
* logical operators
* missing values
